<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Intelligent English to Bliss Translator</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
      background: #f9f9f9;
    }
    textarea {
      width: 100%;
      height: 100px;
      font-size: 1rem;
    }
    #output {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    /* Constrain one dimension for images and maintain aspect ratio */
    #output img {
      max-height: 50px;
      height: auto;
      width: auto;
      vertical-align: middle;
    }
    #output span {
      font-size: 1.2rem;
      color: #555;
    }
    button {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
    }
    #versionContainer {
      margin-top: 2rem;
      font-size: 0.9rem;
      color: #666;
    }
    #updatesBox {
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>Intelligent English to Bliss Translator</h1>
  <p>Enter your phrase below and click "Translate" to see the corresponding Bliss symbols.</p>
  <textarea id="inputText" placeholder="Enter your phrase here..."></textarea>
  <br>
  <button id="translateButton" disabled>Translate</button>
  <div id="output"></div>

  <div id="versionContainer">
    <div id="versionInfo"></div>
    <div id="updatesBox"></div>
  </div>

  <!-- Include the lightweight NLP library, Compromise.js -->
  <script src="https://unpkg.com/compromise"></script>
  <script>
    // Author update and version stamp.
    const AUTHOR_UPDATE = "Notes: Kindly send feedback to info@onewordquran.com, may Allah bless the contributors";
    const modifiedDate = new Date(document.lastModified);
    const versionText = "Version: " + modifiedDate.toLocaleDateString("en-AU") + " " + modifiedDate.toLocaleTimeString("en-AU");
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("versionInfo").textContent = versionText;
      document.getElementById("updatesBox").textContent = AUTHOR_UPDATE + "\n" + versionText;
    });

    // Globals for dictionary mapping.
    let glossToCode = {};
    let glossList = [];

    // Load dictionary file dynamically.
    const dictionaryFile = "BCI-AV_SKOG_2024-10-30_ID_to_gloss_map.txt"; // Update path if needed.
    fetch(dictionaryFile)
      .then(response => {
        if (!response.ok) { throw new Error("Failed to load dictionary file."); }
        return response.text();
      })
      .then(text => {
        processDictionaryData(text);
        // Enable the translate button once the dictionary is loaded.
        document.getElementById("translateButton").disabled = false;
        console.log("Dictionary loaded successfully.");
      })
      .catch(err => {
        console.error("Error loading dictionary:", err);
        document.getElementById("output").innerHTML = `<span>Error loading dictionary. Check the console for details.</span>`;
      });

    // Process dictionary text data (each line: code[TAB]gloss1,gloss2,...)
    function processDictionaryData(dictionaryData) {
      dictionaryData.split('\n').forEach(line => {
        if (line.trim() === "") return;
        const [code, glosses] = line.split('\t');
        glosses.split(',').forEach(word => {
          // Normalize: lower-case and remove annotations like "-(to)"
          let cleaned = word.trim().toLowerCase().replace(/-\(.*\)/, '');
          glossToCode[cleaned] = code;
          glossList.push(cleaned);
        });
      });
      console.log("Processed dictionary:", glossToCode);
    }

    // Fallback fuzzy matching using Levenshtein distance.
    function levenshtein(a, b) {
      const dp = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(0));
      for (let i = 0; i <= a.length; i++) dp[i][0] = i;
      for (let j = 0; j <= b.length; j++) dp[0][j] = j;
      for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)
          );
        }
      }
      return dp[a.length][b.length];
    }

    function findBestMatch(word) {
      let bestMatch = null;
      let bestDistance = Infinity;
      const threshold = Math.max(2, Math.floor(word.length / 2)); // Adjustable threshold.
      glossList.forEach(gloss => {
        const distance = levenshtein(word, gloss);
        if (distance < bestDistance && distance <= threshold) {
          bestDistance = distance;
          bestMatch = gloss;
        }
      });
      return bestMatch;
    }

    // Use Compromise.js to normalize each word (e.g., lemmatize or singularize)
    function normalizeWord(word) {
      let doc = nlp(word);
      let verbForm = doc.verbs().toInfinitive().out('text');
      if (verbForm && verbForm !== "") { return verbForm.toLowerCase(); }
      let nounForm = doc.nouns().toSingular().out('text');
      if (nounForm && nounForm !== "") { return nounForm.toLowerCase(); }
      return word.toLowerCase();
    }

    // The translate function that processes the input and displays SVGs.
    function translate() {
      const inputText = document.getElementById('inputText').value.trim();
      if (!inputText) {
        document.getElementById('output').innerHTML = "<span>No input provided.</span>";
        return;
      }
      const words = inputText.split(/\s+/);
      let outputHTML = "";
      console.log("Translating input:", inputText);
      
      words.forEach(word => {
        let cleanedOriginal = word.replace(/[.,!?]/g, '');
        let normalized = normalizeWord(cleanedOriginal);
        let code = glossToCode[normalized];
        console.log("Processing word:", word, "-> cleaned:", cleanedOriginal, "-> normalized:", normalized, "-> code:", code);
        
        if (!code) {
          const bestMatch = findBestMatch(normalized);
          if (bestMatch) {
            code = glossToCode[bestMatch];
            console.log("Fuzzy matched:", normalized, "->", bestMatch, "-> code:", code);
          }
        }
        if (code) {
          outputHTML += `<img src="bliss_svg_id/${code}.svg" alt="${cleanedOriginal}" title="${cleanedOriginal}"> `;
        } else {
          outputHTML += `<span>${word}</span> `;
        }
      });
      document.getElementById('output').innerHTML = outputHTML;
    }

    // Attach the click event handler after the DOM has loaded.
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("translateButton").addEventListener("click", translate);
    });
  </script>
</body>
</html>
