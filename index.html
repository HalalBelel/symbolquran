<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Intelligent English to Bliss Translator – Strict Mode</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
      background: #f9f9f9;
    }
    textarea {
      width: 100%;
      height: 100px;
      font-size: 1rem;
    }
    #output {
      margin-top: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: flex-start;
    }
    /* Each translated symbol is wrapped in a figure */
    #output figure {
      margin: 0;
      text-align: center;
      display: inline-block;
    }
    /* Constrain SVG images to a maximum height while preserving aspect ratio */
    #output img {
      max-height: 50px;
      height: auto;
      width: auto;
      vertical-align: middle;
    }
    #output figcaption {
      font-size: 0.8rem;
      margin-top: 2px;
      color: #333;
    }
    button {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
    }
    #versionContainer {
      margin-top: 2rem;
      font-size: 0.9rem;
      color: #666;
    }
    #updatesBox {
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>Intelligent English to Bliss Translator – Strict Mode</h1>
  <p>
    Enter your phrase below and click "Translate" to see the corresponding Bliss symbols.
    Under each symbol, the dictionary English (or matched synonym) and definition will appear.
    This version is strict: if an exact match isn’t found, it defaults to a question mark.
  </p>
  <textarea id="inputText" placeholder="Enter your phrase here..."></textarea>
  <br>
  <button id="translateButton" disabled>Translate</button>
  <div id="output"></div>

  <div id="versionContainer">
    <div id="versionInfo"></div>
    <div id="updatesBox"></div>
  </div>

  <!-- Include Compromise.js for lightweight NLP -->
  <script src="https://unpkg.com/compromise"></script>
  <script>
    // Version stamp and author info.
    const AUTHOR_UPDATE = "Notes: Kindly send feedback to info@onewordquran.com, may Allah bless the contributors";
    const modifiedDate = new Date(document.lastModified);
    const versionText = "Version: " + modifiedDate.toLocaleDateString("en-AU") + " " + modifiedDate.toLocaleTimeString("en-AU");
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("versionInfo").textContent = versionText;
      document.getElementById("updatesBox").textContent = AUTHOR_UPDATE + "\n" + versionText;
    });

    // Global variables for our dictionaries.
    let defDict = {};    // from def_dict.json: word -> definition
    let svgDict = {};    // from svg_dict.json: key (possibly comma‐separated words) -> svg filename (including .svg)
    let compDict = {};   // from comp_dict.json: key (possibly comma‐separated) -> array of subcomponent words
    let svgMapping = {}; // Processed mapping: normalized word -> svg filename
    let compMapping = {}; // Processed compound mapping: normalized word -> array of subcomponent words
    const DEFAULT_SYMBOL = "8485"; // Default code for question mark
    const DEFAULT_CAPTION = "question_mark";

    // Load the three JSON files concurrently.
    Promise.all([
      fetch("def_dict.json").then(res => res.json()),
      fetch("svg_dict.json").then(res => res.json()),
      fetch("comp_dict.json").then(res => res.json())
    ]).then(([defData, svgData, compData]) => {
      defDict = defData;
      svgDict = svgData;
      compDict = compData;
      buildSvgMapping();
      buildCompMapping();
      document.getElementById("translateButton").disabled = false;
      console.log("Dictionaries loaded successfully.");
    }).catch(err => {
      console.error("Error loading dictionaries:", err);
      document.getElementById("output").innerHTML = "<span>Error loading dictionaries. Check console for details.</span>";
    });

    // Build svgMapping from svgDict.
    function buildSvgMapping() {
      for (const key in svgDict) {
        const svgFilename = svgDict[key]; // e.g. "combine,connect,link-(to).svg"
        const words = key.split(",").map(s => s.trim().toLowerCase());
        words.forEach(word => {
          svgMapping[word] = svgFilename;
        });
      }
      console.log("SVG Mapping:", svgMapping);
    }

    // Build compMapping from compDict.
    function buildCompMapping() {
      for (const key in compDict) {
        const components = compDict[key]; // an array of subcomponent words
        const words = key.split(",").map(s => s.trim().toLowerCase());
        words.forEach(word => {
          compMapping[word] = components.map(c => c.trim().toLowerCase());
        });
      }
      console.log("Compound Mapping:", compMapping);
    }

    // Normalize a word using Compromise.js.
    function normalizeWord(word) {
      let doc = nlp(word);
      let verbForm = doc.verbs().toInfinitive().out('text');
      if (verbForm && verbForm !== "") { return verbForm.toLowerCase(); }
      let nounForm = doc.nouns().toSingular().out('text');
      if (nounForm && nounForm !== "") { return nounForm.toLowerCase(); }
      return word.toLowerCase();
    }

    // Strict lookup: return an object { svg: filename, caption: text }.
    // If an exact match is found in svgMapping, use it.
    // Else, if there's a compound in compMapping and all subcomponents are found, combine them.
    // Otherwise, return the default symbol.
    function getSvgForWord(word) {
      const normalized = normalizeWord(word.replace(/[.,!?]/g, ''));
      if (svgMapping[normalized]) {
        return { svg: svgMapping[normalized], caption: normalized };
      }
      if (compMapping[normalized]) {
        const components = compMapping[normalized];
        let codes = [];
        let captions = [];
        for (const comp of components) {
          if (svgMapping[comp]) {
            codes.push(svgMapping[comp]); // svg filename already includes .svg
            captions.push(comp);
          } else {
            codes = [];
            break;
          }
        }
        if (codes.length > 0) {
          return { svg: codes.join("+"), caption: captions.join("+") };
        }
      }
      // No match found; return default.
      return { svg: DEFAULT_SYMBOL, caption: DEFAULT_CAPTION };
    }

    // Translate the input text.
    function translate() {
      const inputText = document.getElementById("inputText").value.trim();
      if (!inputText) {
        document.getElementById("output").innerHTML = "<span>No input provided.</span>";
        return;
      }
      const words = inputText.split(/\s+/);
      let outputHTML = "";
      console.log("Translating input:", inputText);
      
      words.forEach(word => {
        const result = getSvgForWord(word);
        // Get definition from defDict if available.
        let definition = defDict[result.caption] || "";
        let captionText = result.caption;
        if (definition) {
          captionText += "<br><em>" + definition + "</em>";
        }
        // If compound (multiple svg filenames joined with '+'), display each.
        if (result.svg.includes("+")) {
          const svgFiles = result.svg.split("+");
          let groupHTML = "<figure>";
          svgFiles.forEach(svgFile => {
            groupHTML += `<img src="bliss_svg_id/${svgFile}" alt="${word}" title="${word}"> `;
          });
          groupHTML += `<figcaption>${captionText}</figcaption></figure> `;
          outputHTML += groupHTML;
        } else {
          outputHTML += `<figure><img src="bliss_svg_id/${result.svg}" alt="${word}" title="${word}"><figcaption>${captionText}</figcaption></figure> `;
        }
      });
      document.getElementById("output").innerHTML = outputHTML;
    }

    // Attach the click event listener.
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("translateButton").addEventListener("click", translate);
    });
  </script>
</body>
</html>
